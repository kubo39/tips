# Gitの仕組み

## Gitとは

その時点においてのディレクトリ配下の管理対象のスナップショットを .git/objects 以下に保持する原始的なシステム

Gitを構成するのは主に

- Gitオブジェクト (`.git/objects` ディレクトリに永続化)
- リファレンス (`.git/refs` ディレクトリに永続化)
- インデックス (`.git/index` ファイルに永続化)

という要素である

## Gitオブジェクト

Gitオブジェクトとは,

- ID: コンテンツのSHA-1ハッシュ
- コンテンツ: ヘッダ情報(Gitオブジェクトの種類と内容のサイズ) + 内容
    - 内容はBlobならファイルの中身、Commitならコミット情報(親のコミット、コメントなど)
    - をzlib圧縮したもの
    - 例えば、あるBlobのコンテンツは `blob 4\0 hoge` のようになる

で構成されている.

Git Objectは4種類ある

- Blob: ファイルのスナップショット
- Tree: ディレクトリのスナップショット
- Commit: コミット情報を保持するオブジェクト
- Tag: アノテートタグにおいてTAGについての注釈を保持するためのオブジェクト
    - たいして使わないので今回は省略

### Blob

Blobオブジェクトとは: ファイルのスナップショット

- ファイルの中身をまるごとzlibで圧縮したものを内容として保持
- Blob自体は自身のファイル名さえ知らない
- ハッシュ値はファイルの内容が同じなら必ず同一になる -> ハッシュ値をみればファイルに変更があったかわかる！

### Tree

Treeオブジェクトとは: ディレクトリのスナップショット

- ファイルの種類,ファイル名 or ディレクトリ名,Blob or TreeのIDを内容として保持,サブモジュールの場合はコミットID
- ファイルの種類: ディレクトリ,ファイル(実行形式or not),シンボリックリンク,サブモジュール
- どこかのディレクトリのIDが変わるとルートまで必ず変更が検知できる
- コミット間で変わってないBlobは作り直さない -> 効率的な差分管理を実現

### Commit

Commitオブジェクトとは: いわゆるGitにおける歴史のページの単位. いつ・だれが・なんのためにファイルツリーを変更したかを管理する.

- 内容は
    1. ルートツリーのID
    2. 親コミットのID
    3. author情報 (名前/メールアドレス/変更時刻)
    4. committer情報 (名前/メールアドレス/変更時刻)
    5. コミットメッセージ
- コマンドラインで作業してるときにみるやつがこれ
- Treeのところでみたようにルートの情報だけもてば変更の有無が全部わかる

## リファレンス

リファレンス: Gitオブジェクトに任意の名前をつける機能. Commitオブジェクトで構成されたコミットツリーのある地点を参照するためのデータ.

- masterブランチと呼んでいるものはあるコミットから過去に辿れるコミットツリーに対して我々が名前をつけているだけ
- HEADは特別なリファレンスで現在チェックアウトしているブランチへの参照になっている
- 通常HEADはリファレンスに対するリファレンスとしてmasterやdevelopを参照
- なので直接commitオブジェクトを参照したときはdetached headと呼ばれる
    - その状態でもコミットはできる
    - ただしその場合HEADがさらに別の場所をさしたときどこからも参照されなくなる
        - どこからも参照されないとやがてgit gcで回収される
        - gcってうまい名前だね

## インデックス

インデックス: ファイル名とBlob(とメタデータ)の対応を保持. スナップショットを作成する対象となるファイルを登録する.

- Treeオブジェクトを作成するための情報を格納
    - `git add` を行うことでインデックスに対象ファイルの ファイル名/メタデータ/BlobのID を追加
        - これをステージングと呼ぶ
    - `git commit` 時にインデックスファイルからTreeオブジェクトを作成してCommitオブジェクトに追加
    - インデックスファイルからコミットを作成してもインデックスファイル自体は消えたりしない

## コマンド

これらを踏まえてコマンドをみてみる

### `git add`

- インデックスのところでふれたようにインデックスファイルにファイル名やBlobオブジェクトの対応を格納する

### `git commit`

1. インデックスファイルからTreeオブジェクトを作る
2. TreeオブジェクトからCommitオブジェクトを作る
3. リファレンス `.git/refs/heads/現在のブランチ名` にCommitオブジェクトのIDを書く

ということをやっている

### `git checkout`

- リファレンスのところで説明したようにHEADの参照先を変える

## マージとリベース

マージ/リベース: どちらも2つのコミットツリーを1つに統合する

方針としては

マージ: マージコミット(2つの親コミットを持つ特別なCommitオブジェクト)を作る
リベース: 片方の歴史を改竄して親を差し替える

という違いがある

### マージコミットを作る

いわゆる `git merge` コマンドで行う操作がこれ

- 操作時にHEADを指しているブランチに吸収されるイメージ

### 歴史を改竄して親を差し替える

いわゆる `git rebase` や `git cherry-pick` コマンドで行う操作がこれ

- 概念的には親を差し替えることによって実現
- `git rebase` する場合は共通の祖先まで遡り, そこから子のCommitオブジェクトをHEADの子として作り直す
    - Commitオブジェクトのところで説明したように親コミットのIDが変われば異なるCommitオブジェクトになる性質
        - うまくできてる(Commitオブジェクトのユニーク性を担保)
- `git cherry-pick` は特定のCommitオブジェクトを選択して作り直しを行う
- `git rebase -i` はこれらの操作を対話的に選択できる
